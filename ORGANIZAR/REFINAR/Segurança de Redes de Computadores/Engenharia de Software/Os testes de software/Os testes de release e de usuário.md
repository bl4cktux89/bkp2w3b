# **Introdu√ß√£o da aula**

[![](https://ampli-images.s3.amazonaws.com/production/cc2f236d-5b67-4717-b1bf-5127b8c09679/original)](https://ampli-images.s3.amazonaws.com/production/cc2f236d-5b67-4717-b1bf-5127b8c09679/original)

### **Qual √© o foco da aula?**

Nesta aula,¬†voc√™ ter√° contato com a base te√≥rica sobre modalidades de teste e sobre registros de atividades no processo.

### **Objetivos gerais de aprendizagem**

Ao longo desta aula, voc√™ ir√°:

- identificar o funcionamento dos testes de unidade e integra√ß√£o;
- examinar os testes de usu√°rio;
- interpretar como s√£o elaborados os relat√≥rios de qualidade do¬†_software_.

**Situa√ß√£o-problema**

Nesta etapa do nosso estudo, j√° concordamos que os testes s√£o fundamentais no processo de desenvolvimento de um produto. Sem que as devidas verifica√ß√µes sejam feitas, n√£o h√° a m√≠nima seguran√ßa de que o sistema se comportar√° conforme o esperado.

A express√£o ‚Äúdevidas verifica√ß√µes‚Äù demanda aten√ß√£o especial de nossa parte: ela indica, entre outras coisas, a necessidade de aplica√ß√£o do teste certo, pela pessoa certa e no tempo devido.

Antes de iniciarmos a abordagem te√≥rica, √© bom que nos lembremos que temos adquirido, ao longo do curso, conhecimento das principais metodologias de desenvolvimento de¬†_software_, das normas de qualidade e, nesta unidade, dos processos de teste de¬†_software_. Temos como objetivo espec√≠fico, nesta aula, conhecer o que s√£o e como implementar o teste de release e o teste de usu√°rio.

Conforme constataremos na sequ√™ncia, n√£o h√° apenas um tipo de teste a ser feito no produto. As verifica√ß√µes devem focar desde o desempenho do programa at√© sua adequa√ß√£o √† m√°quina em que ser√° executado. N√£o se pode conceber tamb√©m que apenas uma pessoa ou grupo realize os testes. Diferentes pontos de vista e interesses devem ser acomodados pelo processo, fato que tamb√©m deu motivo para a cria√ß√£o de v√°rias modalidades de teste.

Ainda resta uma quest√£o a ser abordada: √© v√°lido e √∫til o registro dos resultados obtidos no teste? Podemos considerar esses registros base para cria√ß√£o de hist√≥rico do processo? Desta maneira, ser√° nesta aula que abordaremos esses assuntos que circunstanciam o processo de teste e que ser√£o argumento para o desafio desta aula.

Novamente se faz necess√°rio resgatarmos o desafio que d√° sentido ao nosso curso: fazer com que a¬†_XAX-Sooft_¬†atinja bom n√≠vel de excel√™ncia em seus processos e produtos, tendo como ponto de partida uma organiza√ß√£o sem processo definido e sem qualquer padroniza√ß√£o de qualidade. Em espec√≠fico, nossa miss√£o nesta aula √© fazer o registro dos resultados obtidos com a aplica√ß√£o do teste de¬†_software_¬†como meio eficiente de formar uma base para manuten√ß√£o do hist√≥rico dos processos.

Bons estudos!

# **Testes de unidade e de integra√ß√£o**

[![](https://ampli-images.s3.amazonaws.com/production/1d886edd-f1cf-42ab-b190-286d1e08c781/original)](https://ampli-images.s3.amazonaws.com/production/1d886edd-f1cf-42ab-b190-286d1e08c781/original)

Para entender um teste de unidade, imagine o¬†_software_¬†como um conjunto de partes que, juntas, formam o todo. Essa modalidade de teste √© direcionada a uma rotina, classe ou pequena parte de um produto e √© normalmente executada pelo pr√≥prio desenvolvedor, de modo a assegurar que determinada unidade poder√° ser integrada ao resto do¬†_software_.

No contexto dos testes de unidade (ou testes unit√°rios) insere-se um elemento conhecido como stub. Ele simula resultados que s√£o retornados por um determinado componente do qual o¬†_software_¬†depende (PINHEIRO, 2015). Em outras palavras, um stub √© um trecho de c√≥digo que substituir√° as entradas, depend√™ncias e comunica√ß√µes que a unidade deveria receber em uma execu√ß√£o do programa. Quando um componente A que vai ser testado chama opera√ß√µes de outro componente B que ainda n√£o foi implementado, pode-se criar uma implementa√ß√£o simplificada de B, chamada stub. Neste caso, devemos entender que o componente A √© a unidade a ser testada.

_____

**üìù Exemplificando**

Veja um bom exemplo de aplica√ß√£o de um stub: Suponha que o componente A √© uma classe que deve usar um gerador de n√∫meros primos B. A implementa√ß√£o de B ainda n√£o foi feita. No entanto, para testar a unidade A n√£o ser√° necess√°ria a gera√ß√£o de alguns poucos n√∫meros primos. Assim, B pode ser substitu√≠do por uma fun√ß√£o stub que gera apenas os 5 primeiros n√∫meros primos (WAZLAWICK, 2013).

_____

H√° situa√ß√µes, no entanto, em que o m√≥dulo B j√° est√° implementado, mas o m√≥dulo A (que aqui representa nossa unidade) que chama as fun√ß√µes de B ainda n√£o foi implementado. Dever√° ser implementada, ent√£o, uma simula√ß√£o do m√≥dulo A, que recebe o nome de driver. A diferen√ßa entre stubs e drivers concentra-se na rela√ß√£o de depend√™ncia entre os componentes. As t√©cnicas de teste funcional e estrutural, ambas abordadas anteriormente nesta unidade, podem ser utilizadas para a execu√ß√£o de um teste de unidade.

O teste funcional serve para validar a fun√ß√£o espec√≠fica que est√° sob teste. Quando utilizada, a t√©cnica de teste estrutural (ou caixa-branca) viabiliza a valida√ß√£o dos fluxos de execu√ß√£o da unidade. Ambas as t√©cnicas podem ser utilizadas de forma combinada ou isolada num teste de unidade.

_____

**üí≠ Reflita**

Os stubs, como sabemos, geram valores de entrada para unidades que ser√£o testadas. Voc√™ entende como leg√≠timo que um stub seja constru√≠do tamb√©m para gerar valores errados para a classe, por exemplo?

_____

**Testes de integra√ß√£o**

Trata-se de teste executado pelo testador para garantir que v√°rios componentes do sistema funcionem corretamente juntos (PINHEIRO, 2015). Eles s√£o feitos quando as unidades (as classes, por exemplo) j√° foram testadas de forma isolada e precisam ser integradas para gerar uma nova vers√£o do¬†_software_.

No caso de as classes a serem testadas precisarem de comunica√ß√£o com outros componentes ou classes que ainda n√£o foram testadas ‚Äì ou mesmo implementadas ‚Äì, os stubs mais uma vez ser√£o necess√°rios. O problema com um stub √© que se investe tempo para desenvolver uma fun√ß√£o que n√£o ser√° efetivamente entregue. Al√©m disso, nem sempre √© poss√≠vel saber se a simula√ß√£o produzida pelo stub ser√° suficientemente adequada para os testes (WAZLAWICK, 2013).

Com o sistema integrado e testado, chega o momento de entreg√°-lo ao usu√°rio para que ele o teste tamb√©m.

# **Teste de usu√°rio (ou teste de aceita√ß√£o)**

[![](https://ampli-images.s3.amazonaws.com/production/a358e96b-c2e9-4cde-b567-c110e5b01545/original)](https://ampli-images.s3.amazonaws.com/production/a358e96b-c2e9-4cde-b567-c110e5b01545/original)

Quando j√° se disp√µe da interface final do sistema, o teste de aceita√ß√£o j√° pode ser aplicado. Como o pr√≥prio nome nos faz supor, esse teste √© executado pelo usu√°rio e n√£o pela equipe de testadores ou desenvolvedores. Para entendermos melhor essa modalidade de teste, √© interessante que a coloquemos em oposi√ß√£o ao teste de sistema.

O¬†**teste de sistema**¬†√© feito quando todas as unidades e as integra√ß√µes entre elas j√° foram testadas. Pode ser que a equipe j√° se sinta confiante o bastante nesse ponto para assumir que seu produto √© de boa qualidade. No entanto, √© necess√°rio que ele passe por esse novo teste depois de integrado. O objetivo da sua aplica√ß√£o √© o de verificar se o programa √© capaz de executar processos completos, sempre adotando o ponto de vista do usu√°rio.

Pois bem, o teste de usu√°rio pode ser planejado tal qual o teste de sistema. A diferen√ßa √© que ele ser√° executado pelo usu√°rio. Em outras palavras, enquanto o teste de sistema faz a¬†_verifica√ß√£o_¬†do sistema, o teste de aceita√ß√£o faz sua¬†_valida√ß√£o_.

_____

**üìù Exemplificando**

Um plano vi√°vel para a realiza√ß√£o de teste de aceita√ß√£o em um programa de vendas pela internet √© o que segue no quadro abaixo:

[![](https://ampli-images.s3.amazonaws.com/production/093065d1-cb3a-48ec-b58e-c9c2f146eff2/original)](https://ampli-images.s3.amazonaws.com/production/093065d1-cb3a-48ec-b58e-c9c2f146eff2/original)

Exemplo de roteiro para teste de aceita√ß√£o. Fonte: adaptado de Wazlawick (2013, p. 296).

_____

O teste de aceita√ß√£o √© chamado de¬†**Teste Alfa**¬†quando feito pelo cliente sem planejamento r√≠gido ou formalidades. Se o teste √© ainda menos controlado pelo time de desenvolvimento e as vers√µes do programa s√£o testadas por v√°rios usu√°rios, sem acompanhamento direto ou controle da desenvolvedora, ent√£o o procedimento √© chamado de¬†**Teste Beta**. Nesta modalidade, as vers√µes disponibilizadas costumam expirar depois de certo tempo de uso.

______

**üîÅ Assimile**

O teste de aceita√ß√£o visa √† valida√ß√£o dos requisitos implementados no¬†_software_, n√£o mais a verifica√ß√£o de defeitos (WAZLAWICK, 2013).

______

Um termo bastante comum no contexto dos testes de aceita√ß√£o √© o¬†_release_. Literalmente, o termo refere-se a uma libera√ß√£o ou lan√ßamento de uma nova vers√£o de um produto de¬†_software_. Os testes aplicados sobre um release seguem o padr√£o dos testes de usu√°rio. Usualmente, um lan√ßamento obedece √†s seguintes fases:

- alfa: nesta fase, o lan√ßamento ainda est√° em processo de testes, que s√£o realizados por pessoas situadas normalmente fora do processo de desenvolvimento. Os produtos em fase de teste alfa podem ser inst√°veis e sujeitos a travamento.
- beta: trata-se da classifica√ß√£o posterior a Alfa. Um lan√ßamento em beta teste √© avaliado por testadores beta, normalmente clientes em potencial que aceitam a tarefa de teste sem cobrar por isso. Uma vers√£o Beta √© utilizada para demonstra√ß√µes dentro da organiza√ß√£o e para clientes externos.
- _Release Candidate_: trata-se de vers√£o do sistema com potencial para ser a vers√£o final. Neste caso, todas as funcionalidades j√° foram devidamente testadas por meio das fases Alfa e Beta.

Um¬†_release_¬†pode ser interno ou externo. O primeiro √© usado somente pela equipe interna de desenvolvimento para fins de controle ou para demonstra√ß√£o a clientes e usu√°rios. Um release externo √© uma vers√£o do produto distribu√≠da para os usu√°rios finais (BARTI√â, 2002).

De uma forma ou de outra, as modalidades de teste apresentadas at√© aqui relacionam-se diretamente √†s funcionalidades do sistema. Em outras palavras, elas fazem a verifica√ß√£o dos processos que efetivamente devem ser realizados pelo programa. No entanto, a abrang√™ncia dos testes √© maior e demanda a aplica√ß√£o de outros tipos de verifica√ß√µes no produto. A esses tipos damos o nome de testes suplementares. Vejamos dois exemplos a seguir.

a)¬†**Teste de Desempenho**: tipo que tem por objetivo determinar se, nas situa√ß√µes de pico m√°ximo de acesso e concorr√™ncia, o desempenho ainda permanece consistente com o que foi definido para essa caracter√≠stica do sistema. Assim, o crit√©rio de sucesso aqui √© a obten√ß√£o de tempo de resposta compat√≠vel com o que se espera do produto, quando o sistema trabalha em seu limite. Um plano poss√≠vel para esse teste est√° descrito a seguir (BARTI√â, 2002):

- validar todos os requisitos de desempenho identificados;
- simular n usu√°rios acessando a mesma informa√ß√£o, de forma simult√¢nea;
- simular n usu√°rios processando a mesma transa√ß√£o, de forma simult√¢nea;
- simular n% de tr√°fego na rede;
- combinar todos esses elementos.

Quando o procedimento eleva ao m√°ximo a quantidade de dados e transa√ß√µes √†s quais o sistema √© submetido, o teste realizado √© chamado de¬†**Teste de Estresse**. Ele √© realizado para que se possa verificar se o sistema √© suficientemente robusto em situa√ß√µes extremas de carga de trabalho.

b)¬†**Teste de recupera√ß√£o**: seu objetivo √© avaliar o¬†_software_¬†ap√≥s a ocorr√™ncia de uma falha ou de uma situa√ß√£o anormal de funcionamento. Algumas aplica√ß√µes demandam alta disponibilidade do programa e, no caso de falha, o¬†_software_¬†deve ter a capacidade de se manter em execu√ß√£o at√© que a condi√ß√£o adversa desapare√ßa.

Os testes de recupera√ß√£o devem prever tamb√©m os procedimentos de recupera√ß√£o do estado inicial da transa√ß√£o interrompida, impedindo que determinados processamentos sejam realizados pela metade (BARTI√â, 2002).

Normalmente, o teste de recupera√ß√£o trata de situa√ß√µes referentes a (WAZLAWICK, 2013):

- queda de energia na organiza√ß√£o em que o sistema est√° em funcionamento;
- discos corrompidos;
- problemas de queda de comunica√ß√£o;
- quaisquer outras condi√ß√µes que possam provocar a termina√ß√£o anormal do programa ou a interrup√ß√£o tempor√°ria em seu funcionamento.

_____

**‚ûï Pesquise mais**

√â poss√≠vel que, ao se aplicar uma manuten√ß√£o num programa, outros defeitos sejam gerados no c√≥digo? Acertou se respondeu que sim. Leia o artigo ‚Äú[_A import√¢ncia dos testes de regress√£o_](http://gtsw.blogspot.com/2009/03/importancia-dos-testes-de-regressao.html)‚Äù.

_____

Pois bem, eis ent√£o algumas das outras modalidades de teste e outros conceitos relacionados √† atividade. Chega a hora, ent√£o, de tratarmos dos registros das atividades de teste, visando capacit√°-lo ainda mais para o desafio desta aula. Vamos a eles?

# **Os relat√≥rios da qualidade do software**

[![](https://ampli-images.s3.amazonaws.com/production/8ac004b7-fc36-4ba4-96a6-6508a2cc32bb/original)](https://ampli-images.s3.amazonaws.com/production/8ac004b7-fc36-4ba4-96a6-6508a2cc32bb/original)

O registro das atividades relacionadas ao processo de qualidade, sobretudo os testes, s√£o feitos em relat√≥rios espec√≠ficos. Al√©m do efetivo registro, eles servem tamb√©m como instrumentos de medi√ß√£o e an√°lise. A execu√ß√£o do teste deve gerar o que chamamos de log, que nada mais √© do que o registro das atividades desempenhadas. Vamos a alguns deles:

- log de execu√ß√£o: este documento √© criado para registrar todos os procedimentos realizados durante a execu√ß√£o de um ciclo de testes, bem como apontar as eventuais interrup√ß√µes ocorridas. O log de execu√ß√£o certifica que, de fato, o teste foi realizado.
- ocorr√™ncias da valida√ß√£o: neste documento registram-se todas as ocorr√™ncias geradas durante um teste. Uma ocorr√™ncia pode ser, por exemplo, a identifica√ß√£o de um defeito. Neste caso, alguns dos dados a serem relatados ser√£o: um nome ou n√∫mero de identifica√ß√£o do defeito, a data em que foi encontrado e a sequ√™ncia de a√ß√µes capazes de reproduzi-lo (BARTI√â, 2002).

Um dado tamb√©m bastante importante a ser registrado √© a classifica√ß√£o do defeito. Apesar de haver muitas classifica√ß√µes, alguns deles s√£o mais relevantes:

a)¬†**falha na descri√ß√£o funcional**: esta classifica√ß√£o refere-se √† discrep√¢ncia entre a descri√ß√£o da funcionalidade e sua efetiva implementa√ß√£o. Por exemplo: a descri√ß√£o da funcionalidade estabelece que o programa deveria promover acr√©scimo trimestral autom√°tico do sal√°rio dos gerentes de se√ß√£o e o sistema aplica o aumento a cada quatro meses;

b)¬†**falha no controle, l√≥gica ou sequenciamento do algoritmo**: um la√ßo de repeti√ß√£o infinito √© um exemplo desse tipo de falha;

c)¬†**falha nas estruturas de dados:**¬†trata-se da defini√ß√£o incorreta, por exemplo, de matrizes e tabelas de banco de dados;

O relat√≥rio de teste, em resumo, serve para registrar a maior quantidade poss√≠vel de dados acerca do processo.

_____

**üí™ Fa√ßa voc√™ mesmo**

A norma IEEE 829 √© o padr√£o criado pela IEEE para documenta√ß√£o do processo de teste. Um dos relat√≥rios recomendados pelo padr√£o √© o de incidente de teste, que prev√™ a descri√ß√£o dos seguintes itens, entre outros, em caso de ocorr√™ncia de um incidente: entradas, resultados esperados e resultados encontrados. Vale registrar que um incidente pode ser entendido como discrep√¢ncia entre o resultado esperado e o encontrado na execu√ß√£o dos casos de teste.

Crie um exemplo de um processo de teste que contemple uma entrada de caso de teste, fa√ßa previs√£o de um resultado esperado para aquela entrada e forne√ßa a descri√ß√£o do resultado obtido.

# **Conclus√£o**

[![](https://ampli-images.s3.amazonaws.com/production/3ab1ae4e-ad0a-404f-b930-4492530cb9f6/original)](https://ampli-images.s3.amazonaws.com/production/3ab1ae4e-ad0a-404f-b930-4492530cb9f6/original)

A caminhada da¬†_XAX-Sooft_¬†rumo √† excel√™ncia n√£o para! Depois de fazer a sele√ß√£o dos casos de teste e de efetivamente aplicar teste funcional em um dos seus produtos, a¬†_XAX-Sooft_¬†v√™-se na necessidade de fazer um registro criterioso das atividades desempenhadas no processo de teste, com a finalidade de criar base de compara√ß√£o para testes futuros. Afinal, como saber se a aplica√ß√£o de um m√©todo foi bem-sucedida se n√£o pela compara√ß√£o entre dois ou mais resultados?

Vale a pena dizer que, na pr√°tica, os registros dos resultados obtidos no teste s√£o feitos no ato da sua aplica√ß√£o ou em situa√ß√£o inserida em seu contexto. Por exemplo, as anota√ß√µes referentes √† ocorr√™ncia de uma falha no algoritmo devem ser feitas assim que ela acontece, no momento do teste. Para efeito de organiza√ß√£o did√°tica, esta aula coloca o registro das ocorr√™ncias e resultados como etapa posterior √† aplica√ß√£o do teste, embora n√£o o seja de fato.

Pois bem, o desafio lan√ßado aqui √© justamente o de registrar o processo e os resultados obtidos com a aplica√ß√£o do teste de¬†_software_¬†em um dos seus produtos. O que deve ser registrado? O que n√£o deve ser registrado? H√° formato definido? Uma solu√ß√£o poss√≠vel para esse desafio √© a seguinte:

- A equipe deve criar, oficializar e publicar um log de execu√ß√µes, ou seja, um formul√°rio apropriado para que todos os registros de ocorr√™ncias sejam feitos;
- O formul√°rio de registro deve conter, no m√≠nimo, os seguintes campos:

1. respons√°veis pelo teste;data e hor√°rio de in√≠cio;data e hor√°rio de t√©rmino;¬†fun√ß√£o, unidade ou sistema testados;¬†fase do teste: teste de unidade, teste de integra√ß√£o ou teste de sistema;¬†falha na interpreta√ß√£o da fun√ß√£o: nesta se√ß√£o devem ser relatadas as diverg√™ncias entre a fun√ß√£o especificada nos requisitos e a fun√ß√£o de fato implementada;¬†falha na constru√ß√£o de estrutura de dados: erros na cria√ß√£o de tabelas e outras estruturas devem ser registrados aqui;¬†defeito algor√≠tmico: devem ser identificados erros de l√≥gicas, la√ßos infinitos, por exemplo;travamento de origem n√£o identificada;¬†outras ocorr√™ncias relevantes.

Esse formul√°rio pode ‚Äì e deve ‚Äì passar por constante aprimoramento em seus campos e em sua utiliza√ß√£o.

_____

**‚ö†Ô∏è Aten√ß√£o**

O formato do¬†_log_¬†de execu√ß√µes √© livre e deve ser definido pela equipe, segundo crit√©rios pr√≥prios.

______

**üìåLembre-se**

A norma IEEE 829 √© o padr√£o criado pela IEEE para documenta√ß√£o do processo de teste.